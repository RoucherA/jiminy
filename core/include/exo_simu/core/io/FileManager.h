///////////////////////////////////////////////////////////////////////////////
///
/// \brief FileManager enable filesystem access delegation.
///
/// \copyright Wandercraft
///
///////////////////////////////////////////////////////////////////////////////

#ifndef WDC_SYSTEM_FILE_MANAGER_H
#define WDC_SYSTEM_FILE_MANAGER_H

#include <map>
#include <vector>
#include <string>

#include "exo_simu/core/io/AbstractIODevice.h"
#include "exo_simu/core/io/FileDevice.h"


namespace exo_simu
{
namespace core
{
    namespace protocol
    {
        //////////////////////////////////////////////////////////
        ///                  Protocol description
        ///
        /// handshake (at connexion - open the file on success):
        /// client: | version | filename[128] | OpenMode |
        /// server: | error code (cf. hresult_t) |
        ///
        /// frame:
        /// | cmd | args | payload | crc32 - 0x04C11DB7 (polynom)
        ///
        //////////////////////////////////////////////////////////

        enum version
        {
            V1 = 1,
            N_VERSION
        };

        enum command
        {
            READ     = 0,
            WRITE    = 1,
            GET_SIZE = 2,
            GET_POS  = 3,
            SET_POS  = 4,
            CLOSE    = 5
        };

        struct Handshake
        {
            enum version version;       //!< Protocol version
            char_t filename[128];       //!< Name of the file to open/connect to.
            OpenMode modes;             //!< Requested modes.
            uint32_t checksum;          //!< checksum. WARNING NOT IMPLEMENTED YET
        }__attribute__((__packed__));

        struct FrameHeader
        {
            enum command cmd;   //!< Command of the frame.
            uint64_t timestamp; //!< timestamp of the frame.
            uint32_t dataSize;  //!< Size of the data (may be 0 if no data is associated). In case of read command, requested size to read.
            uint32_t checksum;  //!< checksum of the frame (including the payload if any). WARNING NOT IMPLEMENTED YET
        } __attribute__((__packed__));
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Internal representation of a file for FileManager.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class ManagedFile
    {
        DISABLE_COPY(ManagedFile);

    public:
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Constructor.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ManagedFile(FileDevice* file, AbstractIODevice* firstClient);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Move constructor.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ManagedFile(ManagedFile&& other);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Destructor.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~ManagedFile();

        FileDevice* file_;
        std::vector<AbstractIODevice*> clients_;

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Equality operator.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        bool_t operator==(std::string const& filename);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Move operator.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ManagedFile& operator=(ManagedFile&& other);
    };

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief FileManager handle clients requests and perform filesystem operation (FS delegation). This is
    ///        especially useful when the client don't want to wait for the FS to perform the write.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class FileManager
    {
        DISABLE_COPY(FileManager);

    public:
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Constructor.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FileManager();

        virtual ~FileManager() = default;

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Process a new client (handshake / open the underlying file if required etc).
        ///
        /// \param  client  Client to process.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        hresult_t processNewClient(AbstractIODevice* client);
        void processFiles();

    protected:
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Factory for underlying files. Usefull to test the class properly (enable dependency injection).
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        virtual FileDevice* createFile(std::string const& filename);

    private:
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Process a managed file (process associated clients).
        ///
        /// \param  file  Managed file to process.
        ///
        /// \return true if the client is disconnected, false otherwise (erase-remove idiom).
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        bool_t processFile(ManagedFile& file);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Process a client (handle its requests).
        ///
        /// \param  file  Managed file to process.
        ///
        /// \return true if the client is disconnected, false otherwise (erase-remove idiom).
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        bool_t processClients(AbstractIODevice* io, std::map<uint64_t, std::vector<std::vector<uint8_t>>>& entries);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Helper to find a file with its name.
        ///
        /// \param  name   Name of the file to search.
        /// \param  files  Container to search the file for.
        ///
        /// \return true if the client is disconnected, false otherwise (erase-remove idiom).
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector<ManagedFile>::iterator find(std::string const& name, std::vector<ManagedFile>& files);

        /// Opened files.
        std::vector<ManagedFile> files_;
    };
}
}

#endif
