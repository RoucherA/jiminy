///////////////////////////////////////////////////////////////////////////////
///
/// \brief AbstractIODevice is an interface to handle all possibles I/O that can
///        act as a stream (file / TCP socket / pipe and so on).
///
/// \copyright Wandercraft
///
///////////////////////////////////////////////////////////////////////////////

#ifndef WDC_SYSTEM_ABSTRACT_IO_DEVICE_H
#define WDC_SYSTEM_ABSTRACT_IO_DEVICE_H

#include "exo_simu/core/Types.h"
#include "exo_simu/core/Error.h"

namespace exo_simu
{
namespace core
{
    /// Possible modes for a device (their availability depend of the concrete device).
    enum OpenMode
    {
        NOT_OPEN       = 0x000,  ///< Device is not opened.
        READ_ONLY      = 0x001,  ///< Read only mode.
        WRITE_ONLY     = 0x002,  ///< Write only mode.
        READ_WRITE     = 0x004,  ///< Read/Write mode (WARNING: (READ_ONLY | WRITE_ONLY) != READ_WRITE)
        APPEND         = 0x008,  ///< Open the device in append mode.
        TRUNCATE       = 0x010,  ///< Truncate the device at opening.
        UNBUFFERED     = 0x020,  ///< Do not use intermediate buffer if possible.
        NEW_ONLY       = 0x040,  ///< Create the device at opening, fail if the device already exists.
        EXISTING_ONLY  = 0x080,  ///< Do not create the device if it does not exists.
        NON_BLOCKING   = 0x100,  ///< Open the device in non blocking mode.
        SYNC           = 0x200,  ///< Open the device in sync mode (ensure that write are finished at return).
    };

    /// Facility operators to avoid cast.
    enum OpenMode operator | (enum OpenMode const& modeA, enum OpenMode const& modeB);
    enum OpenMode operator & (enum OpenMode const& modeA, enum OpenMode const& modeB);
    enum OpenMode operator |= (enum OpenMode& modeA, enum OpenMode const& modeB);
    enum OpenMode operator &= (enum OpenMode& modeA, enum OpenMode const& modeB);
    enum OpenMode operator ~(enum OpenMode mode);

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Base interface class for all I/O devices.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class AbstractIODevice
    {
    public:
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Constructor.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        AbstractIODevice();

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Destructor.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        virtual ~AbstractIODevice();

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Open the device.
        ///
        /// \param mode Mode to apply for opening the device.
        ///
        /// \return error::S_OK if successful, another hresult_t value otherwise.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        hresult_t open(enum OpenMode mode);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Write data in the device.
        /// \details The default implementation manage only POD type. For specific type, the template shall be extended
        ///          with specific implementation.
        ///
        /// \param Value to write into the device.
        ///
        /// \return error::S_OK if successful, another hresult_t value otherwise.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void close();

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \return The current opening modes.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        enum OpenMode openModes() const;

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \return The supported opening modes.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        enum OpenMode supportedModes() const;

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \return true if the device is writable, false otherwise.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        bool_t isWritable() const;

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \return true if the device is readable, false otherwise.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        bool_t isReadable() const;

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \return true if the device is opened, false otherwise.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        bool_t isOpen() const;

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \return true if the device is sequential (i.e socket), false if the device support random-access (i.e regular file).
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        virtual bool_t isSequential() const;

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief For random-access devices, this function returns the size of the device.
        ///        For sequential devices, bytesAvailable() is returned.
        ///
        /// \return The size of the device.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        virtual int64_t size();

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Move the current position cursor to pos if possible.
        ///
        /// \param pos  Desired new position of the cursor.
        ///
        /// \return error::S_OK if successful, another hresult_t value otherwise.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        virtual hresult_t seek(int64_t pos);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \return The current cursor position (0 if there is not concept of position cursor).
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        virtual int64_t pos();

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Returns the number of bytes that are available for reading. Commonly used with sequential device.
        ///
        /// \return The available bytesfor reading.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        virtual int64_t bytesAvailable();

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Write data in the device.
        /// \details The default implementation manage only POD type. For specific type, the template shall be extended
        ///          with specific implementation.
        ///
        /// \param Value to write into the device.
        ///
        /// \return error::S_OK if successful, another hresult_t value otherwise.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        template<typename T>
        hresult_t write(T const& valueIn);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Write data in the device.
        ///
        /// \param data      Buffer of data to write.
        /// \param dataSize  Number of bytes to write.
        ///
        /// \return error::S_OK if successful, another hresult_t value otherwise.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        virtual hresult_t write(void const* data, int64_t dataSize);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Write data in the device.
        ///
        /// \param data      Buffer of data to write.
        /// \param dataSize  Number of bytes to write.
        ///
        /// \return the number of bytes written, -1 in case of error (error value can be retrieved with getLastError().
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        virtual int64_t writeData(void const* data, int64_t dataSize) = 0;

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Read data in the device.
        /// \details The default implementation manage only POD type. For specific type, the template shall be extended
        ///          with specific implementation.
        ///
        /// \param Value to store read data.
        ///
        /// \return error::S_OK if successful, another hresult_t value otherwise.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        template<typename T>
        hresult_t read(T& valueIn);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Read data from the device.
        ///
        /// \param data      Buffer to store read data.
        /// \param dataSize  Number of bytes to read.
        ///
        /// \return error::S_OK if successful, another hresult_t value otherwise.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        virtual hresult_t read(void* data, int64_t dataSize);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Read data in the device.
        ///
        /// \param data      Buffer of data to read.
        /// \param dataSize  Number of bytes to read.
        ///
        /// \return the number of bytes read, -1 in case of error (error value can be retrieved with getLastError().
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        virtual int64_t readData(void* data, int64_t dataSize) = 0;

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Retrieve the latest error. Usefull for call that do not return an error code directly.
        ///
        /// \return The latest generated error.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        hresult_t getLastError() const;

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Set the device blocking fashion.
        ///
        /// \return The latest generated error.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        virtual hresult_t setBlockingMode(bool_t shouldBlock);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Set the device backend.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        virtual void setBackend(AbstractIODevice* io);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// \brief Reset the device backend.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        virtual void removeBackend();

    protected:
        virtual hresult_t doOpen(enum OpenMode mode) = 0;
        virtual void doClose() = 0;

        enum OpenMode modes_;           ///< Current opening mode.
        enum OpenMode supportedModes_;  ///< Supported modes of the device.
        hresult_t lastError_;           ///< Latest generated error.
        AbstractIODevice* io_;          ///< Backend to use if any
    };
}
}

#include "AbstractIODevice.tpp"

#endif
